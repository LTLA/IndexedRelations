% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/IndexedRelations.R
\docType{class}
\name{IndexedRelations}
\alias{IndexedRelations}
\alias{IndexedRelations-class}
\alias{partners}
\alias{partners,IndexedRelations-method}
\alias{partners<-}
\alias{partners<-,IndexedRelations-method}
\alias{partnerNames}
\alias{partnerNames,IndexedRelations-method}
\alias{partnerNames<-}
\alias{partnerNames<-,IndexedRelations-method}
\alias{partnerFeatures}
\alias{partnerFeatures,IndexedRelations-method}
\alias{partnerFeatures<-}
\alias{partnerFeatures<-,IndexedRelations-method}
\alias{npartners}
\alias{npartners,IndexedRelations-method}
\alias{featureSetNames}
\alias{featureSetNames,IndexedRelations-method}
\alias{featureSetNames<-}
\alias{featureSetNames<-,IndexedRelations-method}
\alias{featureSets}
\alias{featureSets,IndexedRelations-method}
\alias{featureSets<-}
\alias{featureSets<-,IndexedRelations-method}
\alias{nfeatureSets}
\alias{nfeatureSets,IndexedRelations-method}
\alias{mapping}
\alias{mapping,IndexedRelations-method}
\alias{parallelSlotNames,IndexedRelations-method}
\alias{show,IndexedRelations-method}
\alias{names,IndexedRelations-method}
\alias{names<-,IndexedRelations-method}
\alias{bindROWS,IndexedRelations-method}
\title{The IndexedRelations class}
\description{
The IndexedRelations class is designed to represent relationships between feature sets (e.g., genes, genomic regions, proteins).
Each entry in a IndexedRelations object corresponds to a relationship between any number of \dQuote{partners} from different feature sets.
All entries in a single IndexedRelations object should have the same number, ordering and type of partners involved in the relationship.

This class aims to provide an efficiency boost in the case where one feature is a partner in multiple relationships.
Rather than storing the same feature multiple times, this class stores it once and simply refers to that feature in each relationship.
This reduces the memory usage and enables more efficient processing by algorithms that are aware of this redundancy.
}
\section{Constructor}{

\code{IndexedRelations(x, featureSets=NULL, mapping=NULL)} will return a IndexedRelations object given a list or data.frame of partners in \code{x}.

Partners can be represented by any \linkS4class{Vector}-like data type in each element of \code{x}.
Parallel Vectors in \code{x} represent partners involved in a single relationship, i.e.,
the first element of \code{x[[1]]} is in a relationship with the first element of \code{x[[2]]} and so on.
Thus, all partner vectors in \code{x} should be of the same length.

If \code{featureSets} is specified, this should contain a list of feature sets for each type of feature.
Again, any Vector-like data type is supported, but in this case, \code{x} should only contain integer indices.
This specifies the partners involved in each relationship by indexing the relevant feature set.
By default, each partner vector in \code{x} is assumed to point to the corresponding feature set in \code{featureSets},
i.e., indices in \code{x[[1]]} refer to the elements in \code{featuresSets[[1]]} and so on.

If set, \code{mapping} should be an integer vector of length equal to \code{x},
specifying the index of the feature set in \code{featureSets} that is indexed by each partner vector in \code{x}.
Multiple partner vectors can index the same feature set if the features are shared.
If \code{mapping} is specified, \code{featureSets} must be non-\code{NULL}.

If \code{x} is a IndexedRelations object, it is returned without further modification.
}

\section{Getter methods}{

In the following code snippets, \code{x} is a IndexedRelations object.
\describe{
\item{\code{partners(x)}:}{Returns a \linkS4class{DataFrame} of partner indices.
Each row represents a relationship and each column represents a partner.
The \code{i}th column contains an integer index that points to a feature set defined by \code{mapping(x)[i]}.
}
\item{\code{partnerNames(x)}:}{Returns a character vector of names used for each parter in a relationship.
This may be \code{NULL} if the partners are not named.}
\item{\code{partnerFeatures(x, type)}:}{Returns the partners as features, by using the indices to subset the feature set.
\code{type} can be an integer scalar or a string if the partners are named.}
\item{\code{npartners(x)}:}{Returns an integer scalar specifying the number of partners per relationship in \code{x}.}
\item{\code{featureSets(x)}:}{Returns a \linkS4class{List} of feature sets.
Each entry corresponds to a separate feature set.}
\item{\code{featureSetNames(x)}:}{Returns a character vector of names used for each feature set.
This may be \code{NULL} if the feature sets are not named.}
\item{\code{nfeatureSets(x)}:}{Returns an integer scalar specifying the number of feature sets in \code{x}.}
\item{\code{mapping(x)}:}{Returns an integer vector specifying the mapping from partners to feature sets.
The indices of the \code{i}th partner point towards \code{featureSets(x)[[mapping(x)[i]]]}.}
}
Getter methods applicable to \linkS4class{Vector} subclasses are also applicable here, e.g., \code{length}, \code{names}, \code{mcols}.
}

\section{Setter methods}{

In the following code snippets, \code{x} is a IndexedRelations object.
\describe{
\item{\code{partners(x) <- value}:}{Replaces the partner indices with \code{value}.
\code{value} should have the same number of columns as \code{partners(x)},
and should contain integer indices that point to valid entries of the corresponding feature set.}
\item{\code{partnerNames(x) <- value}:}{Replaces the names used for each partner with \code{value}, a character vector or \code{NULL}.}
\item{\code{partnerFeatures(x, type) <- value}:}{Replaces the partners specified by \code{type} with new features in \code{value}.
Replacement is performed while appending new features to the corresponding feature set in \code{featureSets(x)}.
\code{type} can be an integer scalar or a string if the partners are named.}
\item{\code{featureSets(x) <- value}:}{Replaces the feature sets with \code{value}.
\code{value} should have the same number of feature sets as \code{featureSets(x)},
and each set in \code{value} should be at least as long as the set that it replaces.} 
\item{\code{featureSetNames(x)}:}{Replaces the names used for each feature set with \code{value}, a character vector or \code{NULL}.}
}
Setter methods applicable to \linkS4class{Vector} subclasses are also applicable here, e.g., \code{names<-}, \code{mcols<-}.
}

\section{Subsetting and combining}{

An IndexedRelations instance behaves like a one-dimensional \linkS4class{Vector} during subsetting.
This will operate on the relations as vector elements.

It is possible to combine IndexedRelations with the same feature set classes but different values or orderings.
In such cases, an IndexedRelations object will be produced where each feature set is a union of the corresponding sets in the input.
The same principle applies for subset assignment.
}

\section{Miscellaneous}{

\code{show(x)} will show information about an IndexedRelations \code{x}, including a preview of the first and last relationships.
Note that the feature classes must have methods implemented for \code{\link{showAsCell}} in order for correct display of the partner features.
}

\examples{
#####################
#### Constructor ####
#####################

library(GenomicRanges)
promoters <- GRanges("chrA", IRanges(1:10*20, 1:10*20+10))
enhancers <- GRanges("chrA", IRanges(1:20*10, 1:20*10+10))

# You can construct from supplying features:
partner1 <- sample(length(promoters), 100, replace=TRUE)
partner2 <- sample(length(enhancers), 100, replace=TRUE)
rel <- IndexedRelations(
    list(
        promoter=promoters[partner1],
        enhancer=enhancers[partner2]
    )
)

# But it's more efficient to just supply indices, where possible:
rel <- IndexedRelations(
    list(promoter=partner1, enhancer=partner2),
    featureSets=list(promoters=promoters, enhancers=enhancers)
)

IndexedRelations(rel) # does nothing.

#################
#### Getters ####
#################

partners(rel)
partnerNames(rel)
partnerFeatures(rel, "promoter")
partnerFeatures(rel, 1)
partnerNames(rel)

featureSets(rel)
featureSetNames(rel)

mapping(rel) # always seq_along(featureSets(rel)) for IndexedRelations.

#################
#### Setters ####
#################

rel2 <- rel
partners(rel2)$promoter <- rev(partners(rel2)$promoter)
partners(rel2)

partnerNames(rel2) <- c("P", "E")
partnerNames(rel2)

partnerFeatures(rel2, "P") <- rev(partnerFeatures(rel2, "P")) # by feature
partners(rel2)

featureSets(rel2)$promoters <- resize(featureSets(rel2)$promoters, width=25)
featureSets(rel2)$promoters

featureSetNames(rel2) <- c("Pset", "Eset")
featureSetNames(rel2)

##################################
#### Subsetting and combining ####
##################################

c(rel, rel)
rel[1:5]
rel3 <- rel
rel3[1:10] <- rel[10:1]
rel3

}
\author{
Aaron Lun
}
