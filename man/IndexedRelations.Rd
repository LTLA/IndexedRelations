% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/IndexedRelations.R
\docType{class}
\name{IndexedRelations}
\alias{IndexedRelations}
\alias{IndexedRelations-class}
\title{The IndexedRelations class}
\description{
The IndexedRelations class is designed to represent relationships between feature sets (e.g., genes, genomic regions, proteins).
Each entry in a IndexedRelations object corresponds to a relationship between any number of \dQuote{partners} from different feature sets.
All entries in a single IndexedRelations object should have the same number, ordering and type of partners involved in the relationship.

This class aims to provide an efficiency boost in the case where one feature is a partner in multiple relationships.
Rather than storing the same feature multiple times, this class stores it once and simply refers to that feature in each relationship.
This reduces the memory usage and enables more efficient processing by algorithms that are aware of this redundancy.
}
\section{Constructor}{

\code{IndexedRelations(x, featureSets=NULL, mapping=NULL)} will return a IndexedRelations object given a list or data.frame of partners in \code{x}.

Partners can be represented by any \linkS4class{Vector}-like data type in each element of \code{x}.
Parallel Vectors in \code{x} represent partners involved in a single relationship, i.e.,
the first element of \code{x[[1]]} is in a relationship with the first element of \code{x[[2]]} and so on.
Thus, all partner vectors in \code{x} should be of the same length.

If \code{featureSets} is specified, this should contain a list of feature sets for each type of feature.
Again, any Vector-like data type is supported, but in this case, \code{x} should only contain integer indices.
This specifies the partners involved in each relationship by indexing the relevant feature set.
By default, each partner vector in \code{x} is assumed to point to the corresponding feature set in \code{featureSets},
i.e., indices in \code{x[[1]]} refer to the elements in \code{featuresSets[[1]]} and so on.

If set, \code{mapping} should be an integer vector of length equal to \code{x},
specifying the index of the feature set in \code{featureSets} that is indexed by each partner vector in \code{x}.
Multiple partner vectors can index the same feature set if the features are shared.
If \code{mapping} is specified, \code{featureSets} must be non-\code{NULL}.

If \code{x} is a IndexedRelations object, it is returned without further modification.
}

\section{Getter methods}{

In the following code snippets, \code{x} is a IndexedRelations object.
\describe{
\item{\code{partners(x)}:}{Returns a \linkS4class{DataFrame} of partner indices.
Each row represents a relationship and each column represents a partner.
The \code{i}th column contains an integer index that points to a feature set defined by \code{mapping(x)[i]}.
}
\item{\code{partnerNames(x)}:}{Returns a character vector of names used for each parter in a relationship.
This may be \code{NULL} if the partners are not named.}
\item{\code{partner(x, type, id=FALSE)}:}{If \code{id=TRUE}, this returns an integer index for the partner specified by \code{type}.
If \code{id=FALSE}, this returns the partners as features.
\code{type} can be an integer scalar or a string if the partners are named.}
\item{\code{featureSets(x)}:}{Returns a \linkS4class{List} of feature sets.
Each entry corresponds to a separate feature set.}
\item{\code{featureSetNames(x)}:}{Returns a character vector of names used for each feature set.
This may be \code{NULL} if the feature sets are not named.}
\item{\code{mapping(x)}:}{Returns an integer vector specifying the mapping from partners to feature sets.
The indices of the \code{i}th partner point towards \code{featureSets(x)[[mapping(x)[i]]]}.}
}
}

\section{Setter methods}{

In the following code snippets, \code{x} is a IndexedRelations object.
\describe{
\item{\code{partners(x) <- value}:}{Replaces the partner indices with \code{value}.
\code{value} should have the same number of columns as \code{partners(x)},
and should contain integer indices that point to valid entries of the corresponding feature set.}
\item{\code{partnerNames(x) <- value}:}{Replaces the names used for each partner with \code{value}, a character vector or \code{NULL}.}
\item{\code{partner(x, type, id=FALSE) <- value}:}{If \code{id=TRUE}, this replaces the indices for the partner specified by \code{type} with new integer indices in \code{value}.
If \code{id=TRUE}, \code{value} is assumed to contain the partners as features,
and replacement is performed while appending new features to the corresponding feature set in \code{featureSets(x)}.
\code{type} can be an integer scalar or a string if the partners are named.}
\item{\code{featureSets(x) <- value}:}{Replaces the feature sets with \code{value}.
\code{value} should have the same number of feature sets as \code{featureSets(x)},
and each set in \code{value} should be at least as long as the set that it replaces.} 
\item{\code{featureSetNames(x)}:}{Replaces the names used for each feature set with \code{value}, a character vector or \code{NULL}.}
}
}

\section{Combining and subsetting}{

An IndexedRelations instance behaves like a vector in terms of subsetting and combining.
Specifically, it behaves like any other one-dimensional \linkS4class{Vector} subclass.
}

\section{Miscellaneous}{

\code{show(x)} will show information about an IndexedRelations \code{x}, including a preview of the \code{\link{head}} relationships.
Only the top elements are shown to avoid inconsistencies with the display of arbitrary Vector-like feature sets.
}

\examples{
#####################
#### Constructor ####
#####################

library(GenomicRanges)
promoters <- GRanges("chrA", IRanges(1:10*20, 1:10*20+10))
enhancers <- GRanges("chrA", IRanges(1:20*10, 1:20*10+10))

# You can construct from supplying features:
partner1 <- sample(length(promoters), 100, replace=TRUE)
partner2 <- sample(length(enhancers), 100, replace=TRUE)
rel <- IndexedRelations(
    list(
        promoter=promoters[partner1],
        enhacner=enhancers[partner2]
    )
)

# But it's more efficient to just supply indices, where possible:
rel <- IndexedRelations(
    list(promoter=partner1, enhancer=partner2),
    featureSets=list(promoters=promoters, enhancers=enhancers)
)

IndexedRelations(rel) # does nothing.

#################
#### Getters ####
#################

partners(rel)
partnerNames(rel)
partner(rel, "promoter")
partner(rel, 1, id=TRUE)
partnerNames(rel)

featureSets(rel)
featureSetNames(rel)

mapping(rel) # always seq_along(featureSets(rel)) for IndexedRelations.

#################
#### Setters ####
#################

rel2 <- rel
partners(rel2)$promoter <- rev(partners(rel2)$promoter)
partners(rel2)

partnerNames(rel2) <- c("P", "E")
partnerNames(rel2)

partner(rel2, "P") <- rev(partner(rel2, "P")) # by feature
partners(rel2)

partner(rel2, "E", id=TRUE) <- rev(partner(rel2, "E", id=TRUE)) # by ID
partners(rel2)

featureSets(rel2)$promoters <- resize(featureSets(rel2)$promoters, width=25)
featureSets(rel2)$promoters

featureSetNames(rel2) <- c("Pset", "Eset")
featureSetNames(rel2)

##################################
#### Subsetting and combining ####
##################################

c(rel, rel)
rel[1:5]
rel3 <- rel
rel3[1:10] <- rel[10:1]
rel3

}
\author{
Aaron Lun
}
