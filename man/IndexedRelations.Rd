% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/IndexedRelations.R
\docType{class}
\name{IndexedRelations}
\alias{IndexedRelations}
\alias{IndexedRelations-class}
\title{The IndexedRelations class}
\description{
The IndexedRelations class is designed to represent relationships between feature sets (e.g., genes, genomic regions, proteins).
Each entry in a IndexedRelations object corresponds to a relationship between any number of \dQuote{partners} from different feature sets.
All entries in a single IndexedRelations object should have the same number, ordering and type of partners involved in the relationship.

This class aims to provide an efficiency boost in the case where one feature is a partner in multiple relationships.
Rather than storing the same feature multiple times, this class stores it once and simply refers to that feature in each relationship.
This reduces the memory usage and enables more efficient processing by algorithms that are aware of this redundancy.
}
\section{Constructor}{

\code{IndexedRelations(x, features=NULL)} will return a IndexedRelations object given a list or data.frame of features in \code{x}.
Features can be represented by any \linkS4class{Vector}-like data type in each element of \code{x}.
Parallel elements of \code{x} represent partners involved in a single relationship, i.e.,
the first element of \code{x[[1]]} is in a relationship with the first element of \code{x[[2]]} and so on.
Thus, all elements of \code{x} should be of the same length.

If \code{features} is specified, this should contain a list of feature sets for each type of feature.
In this case, \code{x} should only contain integer indices.
This specifies the partners involved in each relationship by indexing the relevant feature set.
Each element of \code{x} is assumed to point to the corresponding element of \code{features},
i.e., the first element of \code{x} contains indices to the first element of \code{features} and so on.

If \code{x} is a IndexedRelations object, it is returned without further modification.
}

\section{Getter methods}{

In the following code snippets, \code{x} is a IndexedRelations object.
\describe{
\item{\code{partners(x)}:}{Returns a \linkS4class{DataFrame} of partner indices.
Each row represents a relationship and each column represents a partner.
The \code{i}th column contains an integer index that points to a feature set defined by \code{mapping(x)[i]}.
}
\item{\code{partnerNames(x)}:}{Returns a character vector of names used for each parter in a relationship.
This may be \code{NULL} if the partners are not named.}
\item{\code{partner(x, type, id=FALSE)}:}{If \code{id=TRUE}, this returns an integer index for the partner specified by \code{type}.
If \code{id=FALSE}, this returns the partners as features.
\code{type} can be an integer scalar or a string if the partners are named.}
\item{\code{featureSets(x)}:}{Returns a \linkS4class{List} of feature sets.
Each entry corresponds to a separate feature set.}
\item{\code{featureSetNames(x)}:}{Returns a character vector of names used for each feature set.
This may be \code{NULL} if the feature sets are not named.}
\item{\code{mapping(x)}:}{Returns an integer vector specifying the mapping from partners to feature sets.
The indices of the \code{i}th partner point towards \code{featureSets(x)[[mapping(x)[i]]]}.}
}
}

\section{Setter methods}{

In the following code snippets, \code{x} is a IndexedRelations object.
\describe{
\item{\code{partners(x) <- value}:}{Replaces the partner indices with \code{value}.
\code{value} should have the same number of columns as \code{partners(x)},
and should contain integer indices that point to valid entries of the corresponding feature set.}
\item{\code{partnerNames(x) <- value}:}{Replaces the names used for each partner with \code{value}, a character vector or \code{NULL}.}
\item{\code{partner(x, type, id=FALSE) <- value}:}{If \code{id=TRUE}, this replaces the indices for the partner specified by \code{type} with new integer indices in \code{value}.
If \code{id=TRUE}, \code{value} is assumed to contain the partners as features,
and replacement is performed while appending new features to the corresponding feature set in \code{featureSets(x)}.
\code{type} can be an integer scalar or a string if the partners are named.}
\item{\code{featureSets(x) <- value}:}{Replaces the feature sets with \code{value}.
\code{value} should have the same number of feature sets as \code{featureSets(x)},
and each set in \code{value} should be at least as long as the set that it replaces.} 
\item{\code{featureSetNames(x)}:}{Replaces the names used for each feature set with \code{value}, a character vector or \code{NULL}.}
}
}

\section{Combining and subsetting}{

An IndexedRelations instance behaves like a vector in terms of subsetting and combining.
Specifically, it behaves like any other one-dimensional \linkS4class{Vector} subclass.
}

\section{Miscellaneous}{

\code{show(x)} will show information about an IndexedRelations \code{x}, including a preview of the \code{\link{head}} relationships.
}

\examples{
#####################
#### Constructor ####
#####################

library(GenomicRanges)
promoters <- GRanges("chrA", IRanges(1:10*20, 1:10*20+10))
enhancers <- GRanges("chrA", IRanges(1:20*10, 1:20*10+10))

# You can construct from supplying features:
partner1 <- sample(length(promoters), 100, replace=TRUE)
partner2 <- sample(length(enhancers), 100, replace=TRUE)
rel <- IndexedRelations(
    list(
        promoter=promoters[partner1],
        enhacner=enhancers[partner2]
    )
)

# But it's more efficient to just supply indices, where possible:
rel <- IndexedRelations(
    list(promoter=partner1, enhancer=partner2),
    features=list(promoters=promoters, enhancers=enhancers)
)

IndexedRelations(rel) # does nothing.

#################
#### Getters ####
#################

partners(rel)
partnerNames(rel)
partner(rel, "promoter")
partner(rel, 1, id=TRUE)
partnerNames(rel)

featureSets(rel)
featureSetNames(rel)

mapping(rel) # always seq_along(featureSets(rel)) for IndexedRelations.

#################
#### Setters ####
#################

rel2 <- rel
partners(rel2)$promoter <- rev(partners(rel2)$promoter)
partners(rel2)

partnerNames(rel2) <- c("P", "E")
partnerNames(rel2)

partner(rel2, "P") <- rev(partner(rel2, "P")) # by feature
partners(rel2)

partner(rel2, "E", id=TRUE) <- rev(partner(rel2, "E", id=TRUE)) # by ID
partners(rel2)

featureSets(rel2)$promoters <- resize(featureSets(rel2)$promoters, width=25)
featureSets(rel2)$promoters

featureSetNames(rel2) <- c("Pset", "Eset")
featureSetNames(rel2)

##################################
#### Subsetting and combining ####
##################################

c(rel, rel)
rel[1:5]
rel3 <- rel
rel3[1:10] <- rel[10:1]
rel3

}
\author{
Aaron Lun
}
